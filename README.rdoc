云币在ubuntu下的安装参考：<br>
https://github.com/peatio/peatio/blob/master/doc/setup-local-ubuntu.md <br>

云币官方网站： https://yunbi.com/

bitcoin网络： <br>
https://en.bitcoin.it/wiki/Bitcoind <br>

了解比特币测试网络？<br>
怎么生成钱包？<br>
怎么给钱包增加比特币<br>
比特币协议变更方式<br>
云币的操作模式<br>
云币的总账户拥有或购买一定数量的比特币，进行交易的前提<br>
用户有两种充值方式，充值人民币到平台制定的银行账户，从自己的有比特币地址的账户充值到平台比特币地址（这个未确认？）<br>
用户购入或卖出比特币，云币平台只记录交易信息，并改变账户或比特币账户的余额<br>
用户提现操作，人民币提现，直接提现到自己的银行账户里面，比特币提现，提供自己的地址，然后交一定的手续费就可以从云币平台提取比特币，这时候交易就确认了吗？fix
云币的职责，促成交易？保证公平，为市场提供比特币<br>
云币<br>
云币上的注册<br>
注册及验证<br>
两段验证<br>
云币的上会员对应members表，每个member表对应一个账户accounts表<br>
云币网的特征<br>
Features<br>

Designed as high performance crypto currency exchange.<br>
被设计用来高性能货币交换<br>
Built-in high performance matching-engine.<br>
内建高性能匹配引擎<br>
Built-in Proof of Solvency Audit.<br>
<br>
Built-in ticket system for customer support.<br>
在客户支持方面内建票务系统<br>
Usability and scalibility.<br>
可用性和可扩展性<br>
Websocket API and high frequency trading support.<br>
Websocket API和高频交易支持<br>
Support multiple digital currencies (eg. Bitcoin, Litecoin, Dogecoin etc.).<br>
支持多个电子货币（如：Bitcoin, 莱特币，Dogecoin 等)<br>
Easy customization of payment processing for both fiat and digital currencies.<br>
? 易定制支付处理对于新发布电子货币？（不懂）<br>
SMS and Google Two-Factor authenticaton.<br>
短信和谷歌两段验证（授权）<br>
KYC Verification.<br>
<br>
Powerful admin dashboard and management tools.<br>
强大的管理面板和管理工具<br>
Highly configurable and extendable.<br>
高可配、高扩展<br>
Industry standard security out of box.<br>
工业安全标准<br>
Active community behind.<br>
活跃社区<br>
Free and open-source.<br>
开源<br>
Created and maintained by Peatio open-source group.<br>
由Peatio开源团队创建和维护<br>
<br>
<br>
RabbitMQ介绍： <br>
http://baike.baidu.com/view/4095865.htm <br>
<br>

=== 用户买入（ask）或卖出（bid）比特币的程序流程为：

user ask or bid from web or api ->  # 用户通过浏览器或API提交订单<br>
Private::OrderBidsController.create 或者 Private::OrderAsksController.create -> # 创建买入或卖出订单<br>
Concerns::OrderCreation.order_submit -> # 提交订单<br>
Ordering#submit -> # 提交订单<br>
Ordering#do_submit -> # 提交订单到数据库(order)，锁定相应的金额(amount*volume)<br>
AMQPQueue.enqueue -> # 将每个订单进入队列 队列的定义： app/models/amqp_queue.rb<br>
<br>
队列就放到了RabbitMQ服务器中<br>(为了保证交易顺序）
# lib/daemons/matching_ctl 守护进程注册了matching服务<br>
daemon会启动相应的服务worker，文件位于 app/models/worker/matching.rb<br>
<br>
RabbitMQ会将消息发送给订阅了matching的customer<br>
Worker::Matching.process -> # 根据类型（ask or bid or market)，如submit来调用不同的服务<br>
Matching::OrderBookManager.build_order -><br>
Worker::Matching.submit -><br>
Matching::Engine.submit -><br>
Matching::Engine.match -> # 反复match<br>
每匹配成功一次，发送一条消息trade_executor<br>
以下才是执行真正的数据库操作
<br>
Worker::TradeExecutor.process -><br>
Matching::Executor.execute! -><br>
<br>
<br>
AMQPQueue<br>
<br>
怎么确保交易公平？<br>
就是按价格，然后顺序排就可以，锁表的形式并发能达到多大呢？<br>
<br>
<br>
RabbitMQ中的消费者，生产者<br>
<br>
<br>
<br>
不通过挖矿产生比特币，开始怎么生成比特币的所有者？<br>
<br>
还是靠传统信用？<br>
<br>
术语：<br>
地址：<br>
钱包：<br>
Tx：<br>
order book: 订货单<br>
limit order: 限价委托<br>
market order: 市场价委托<br>
price level: 物价水平<br>
strike price: 履约价格<br>
base unit: 基本单位
quote　unit：　报价单位
<br>
2015-9-28
==============================
# 关于daemons的启动，如果非正常关机，由于pid是存在于文件中的，再次启动daemon服务时，会读取该文件，如果文件的pid存在，但是不会去验证该服务是否还在，导致无法启动，这时候要么删除掉所有的以pid结尾的文件<br>
# limit订单和market订单的区别？<br>
一个是限价委托，一个是市场委托<br>
类似股票中的价格，当前的价格为市场价格<br>
# limit订单中的price是什么价格？<br>

2015-9-29
==============================
# 添加或取消或成交操作是哪个来实现通知到所有正在交易的人员？<br>
# 如果是买入，就和卖出的所有比较，卖出则相反，因为之前的交易肯定以达到平衡了<br>
# RabbitMQ消息服务器用来限制执行的顺序，如果一笔交易正在执行时，服务器重启后应该不会在从消息队列里面取消息了<br>
# 列出所有的服务？<br>

2015-10-16
==============================
用到的技术栈
语言和框架： ruby, RoR
缓存：redis
消息pusher服务：  http://pusher.com
优点：如果链接的客户端很多的话，直接从服务器获取最新消息的话，会使服务器压力增加
通过pusher提供的服务，可以直接向pusher服务器发送消息，pusher服务器负责来更新消息
更新哪些消息：
private-#{sn},这个表字段sn估计是专门为发送pusher而生成的，这样就不用暴漏账户id信息

消息服务器：RabbitMQ，为什么选择RabbitMQ,其他消息服务器介绍及对比，优势，缺点
配置简单，单机，性能符合peatio的要求, 当机消息队列会保存，信息不会丢失
介绍流程

项目的目的：介绍

所有的守护进程
rake daemon:deposit_coin                                         # Start deposit_coin script
rake daemon:global_state                                         # Start global_state script
rake daemon:hot_wallets                                          # Start hot_wallets script
rake daemon:k                                                    # Start k script
rake daemon:market_data                                          # Start market_data script
rake daemon:matching                                             # Start matching script
rake daemon:notification                                         # Start notification script
rake daemon:order_processor                                      # Start order_processor script
rake daemon:payment_transaction                                  # Start payment_transaction script
rake daemon:pusher                                               # Start pusher script
rake daemon:stats                                                # Start stats script
rake daemon:trade_executor                                       # Start trade_executor script
rake daemon:websocket_api                                        # Start websocket_api script
rake daemon:withdraw_audit                                       # Start withdraw_audit script
rake daemon:withdraw_coin                                        # Start withdraw_coin script
守护进程用到的gem，使用守护进程的作用

daemon:deposit_coin
注册：'peatio:amqp:deposit_coin'
功能：Sync coin deposit transactions同步货币保证金交易？
主要是将未记录数据库的交易重新存入数据库
coin.rake,
rake coin:sync_deposit
启动任务时，将未完成的交易放到队列中进行交易
deposit_coin.rb中的depoisit!来处理这笔交易
检查该交易，如果该交易并不存在于数据库中，则创建该笔交易

daemon:global_state
global_state.rb
global.rb
获取所有的交易，24小时的交易记录，成交量，最佳买入、卖出价，通过pusher更新

daemon:hot_wallets
hot_wallets.rb
currency.rb
peatio:hotwallet:cny:balance
peatio:hotwallet:btc:balance
每5秒钟刷新一次所有币种的余额

daemon:k
k.rb
每15秒获得一次1，5,15等等分钟数的K线数据并存储到redis中
15秒的设定，其实最主要的是最新的买单和卖单，k线只是看趋势，所以15秒可以接受
1分钟k线数据会push到redis服务器中，其它时间段的数据由1分钟数据算出
@r.rpush k, point.to_json # 其中@r为redis对象，k="peatio:btccny:k:1"
每个数据点的格式为

[时间点, 第一个价格(开盘价）, 最高价, 最低价, 最后一个价格（收盘价）, 这个时间段成交的总量]

daemon:market_data
slave_book.rb
每三秒钟缓存一次:买单和卖单价格对应的数量,这个数据也是供global使用
def asks
    Rails.cache.read("peatio:#{currency}:depth:asks") || []
end

daemon:notification
说明：通知
两种通知方式：短信和邮件
sms_notification email_notification

daemon:order_processor
order_processor.rb
每5秒钟检查一次，用来处理取消的订单
取消订单成功后会释放锁定的资金
如果该订单部分成交或已成交，则该订单无法取消

daemon:payment_transaction

daemon:pusher
存在两个pusher，
pusher_market
pusher_member
向会员发送ask和bid的push消息

daemon:stats
每30秒执行一次状态检查，包括会员状态

# 利于扩展
用途
交易市场，目前只有人民币对比特币的市场
用户注册
用户通过转账的方式存入人民币，或直接用人民币购买比特币，这时候需要用户提供比特币地址（地址）
比特币的几个概念
创世块，地址，钱包，挖矿（奖励机制，矿池）
用户通过转账的方式存入人民币，或直接用人民币购买比特币，这时候需要用户提供比特币地址（地址）
这时候用户就可以在交易大厅进行比特币交易了，

2015.11.4
================
1. 特别会员，会员单位，普通会员（交易商管理），商品管理（IPO），例如：普洱茶等商品
2. 交易节的概念，开放时间
3. 手续费，佣金

交易系统运营人员:
特别会员:
会员单位: 会员编号，会员名称，会员类型（经济业务基本账户），证件类型（机构代码，营业执照），证件号码，传真号码，邮政编码，电子邮箱，联系电话，通讯地址
普通会员: 客户类型，所属会员单位，所属机构，交易账号（符合规律），所属居间，客户名称，证件类型，证件号码（身份证，机构代码，营业执照）

现有系统注册一个会员涉及到的表：
identities：用户登陆验证
members：会员基本信息created_at
read_marks：(暂时不知道）
id_documents：实名验证信息
增加：会员编号:uid, 会员名称
增加会员类型：member_type: 普通会员（交易商）, 所属机构organization（会员单位所属机构为？），会员单位，identity_type(身份证，机构代码，营业执照), 证件号码，传真号码，邮政编码，联系电话，通讯地址
accounts：自动创建两个账户，人民币和比特币目前
tokens: 邮箱验证
signup_histories：用户登录历史信息

佣金表：

member_type: 会员单位：0， 普通会员：1
证件类型：5种，整理出来
member应该是自属于的，has_many :members , 雇员和雇主的关系

2015.11.10
======================
手续费：交易手续费（买和卖），入金手续费，出金手续费
withdraw： 提现（出金）
deposit: 充值（入金）
account_versions：显示所有币种账户的变动明细表
order买单和卖单的状态：0-cancel, 100-wait,200-done
trade的最后一笔成交价为当前价格，其中trend为走势，是卖方还是买方市场？
worker:matching 再收到on_usr2信号时，会复制当前的红黑树
核心交易算法是使用gem：rbtree来实现的，底层是由c++实现
market_orders:RBtree直接按照先后顺序成交
按照价格组成红黑树，然后每个价格下面是按照时间顺序组成的数组

如果价格相差不大，怎么成交
会员单位：
lixiumiao@qq.com
test@danwei.com
会员单位下的交易商
lixiumiao@jsdttec.com
test@jiaoyishang.com
清除redis缓存：Rails.cache
输入：redis-cli
FLUSHALL
清除全部消息队列：
rabbitmqctl stop_app
rabbitmqctl reset    # Be sure you really want to do this!
rabbitmqctl start_app

手续费(目前是卖出手手续费，应该是买入的人多出手续费）：
1. 交易商的手续费，根据分成比例，在交易完成（状态：done）之后，打到交易商所属会员单位的账户上，并在
账户变动明细表上添加一个金额变动（未完成）
需要增加一个fun： fee=>6
账户金额变动邮件：
2. 会员单位的手续费处理目前同上，也是扣完之后返回到会员账户上，费率比例目前相同，未来可以在表fees中添加另外的费率
3. 平台的手续费：统计所有账户变动fee的sum值，就可以计算出平台应拿到的费用

1. 公告功能
2. 开市，演示功能
3. 节假日管理


有效申购单位数量 = 发行总量（股）/1000
实际申购有效单位数量 = 申购资金总额/（股票单价×1000）
中签率 = 有效申购单位数量/实际申购有效单位数量
1. 用户申购必须大于1个有效单位即（1000股）
2. 用户有申购上限
3. 股票发行价
4. 申购时间区间
5. 退还费用（T-3)
6. 产品名称（如普洱茶）
7. 产品单位（KG）
8. 可以买卖的时间
9.
表格：ipo_applicants
产品名称：production,
产品基本单位：base_unit,
产品发行价：issue_price
产品发行总量：total_stock
申购份数： ipo_count  = total_stock/1000
用户申购上限：top_limit
申购起始日期：start_time
申购截止日期：end_time
审核状态：state
申请会员单位：member_id
审核人员：audit_id
审核时间： audit_time

ipos
产品id: pre_ipo_id
申请人： member_id
申请数量： amount
中签数量： count
中签状况: state

ipo_numbers
申请人ipo_id: ipo_id

限制只有

1. ipo结束之后，没有把对应的数量的商品保存到对应的申购者账户中，没有把账户的解冻金额添加到IPO发行机构的账户上
2. 机器人脚本
1）获取需要购买商品的当前市价
2）买入和卖出随机数量（价格上下浮动10%）
3.
和pusher.com类似的开源软件
https://www.quora.com/Are-there-any-open-source-alternatives-to-Pusher
激活邮箱
UPDATE members` SET `activated` = 1 WHERE members.id = 9
实名认证
UPDATE `id_documents` SET `aasm_state` = 'verified', `updated_at` = '2015-11-23 10:52:43' WHERE `id_documents`.`id` = 9
手机认证
UPDATE `members` SET `phone_number` = '86111111', `updated_at` = '2015-11-23 11:55:22' WHERE `members`.`id` = 9
UPDATE `two_factors` SET `activated` = 1, `last_verify_at` = '2015-11-23 11:55:25' WHERE `two_factors`.`type` IN ('TwoFactor::Sms') AND `two_factors`.`id` = 17

192.168.150.92
添加两个会员单位
company1@company.com
company2@company.com
属于会员单位的交易商
member1@jiaoyishang.com
member2@jiaoyishang.com
member3@jiaoyishang.com
member4@jiaoyishang.com

